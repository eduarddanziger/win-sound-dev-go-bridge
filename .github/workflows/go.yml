# This workflow will build a golang project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-go

name: Go

on:
  push:
    branches:
      - main
    tags:
      - 'Release-*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  setup-and-compute-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.VERSION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Unshallow repository
        run: git fetch --prune --unshallow

      - name: Determine version (SemVer)
        id: get_version
        shell: pwsh
        run: |
          $ref = $env:GITHUB_REF
          # Find the latest Release-* tag.
          $latestTag = git describe --tags --match "Release-*" --abbrev=0
          if (-not $latestTag) {
              Write-Host "No Release tag found. Using default version 1.0.0."
              "VERSION=1.0.0" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "version=1.0.0" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              exit 0
          }
          # Extract version number from the tag (e.g., Release-1.0.1 -> 1.0.1)
          $versionNumber = $latestTag -replace '^Release-', ''
          Write-Host "latestTag: $latestTag, versionNumber: $versionNumber"
          $distance = git rev-list --count "$latestTag..HEAD"
  
          # Append -rc<distance> if distance is greater than 0
          if ($distance -gt 0) {
              # Increment the patch number for a prerelease build
              $versionParts = $versionNumber -split '\.'
              $versionParts[2] = [int]$versionParts[2] + 1
              $versionNumber = $versionParts -join '.'
              Write-Output "VERSION CORRECTED, versionNumber: $versionNumber"
              $version = "$versionNumber-rc.$distance"
          } else {
              $version = $versionNumber
          }
          $version = 'v' + $version
          Write-Host "Derived development version: $version (base tag: $latestTag)"
          "VERSION=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Using version: $version"

  build:
    runs-on: windows-latest
    needs: setup-and-compute-version
    permissions:
      contents: read
      packages: write
    env:
      IMAGE_NAME: ghcr.io/${{ github.repository }}
      VERSION: ${{ needs.setup-and-compute-version.outputs.version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.x"

      - name: Install llvm-mingw (clang toolchain for CGO)
        shell: powershell
        run: |
          # NOTE: keep this in sync with a real llvm-mingw release tag
          $url = "https://github.com/mstorsjo/llvm-mingw/releases/download/20240619/llvm-mingw-20240619-msvcrt-x86_64.zip"
          $zip = Join-Path $Env:TEMP "llvm-mingw.zip"
          $destRoot = "C:\tools"
          $dest = Join-Path $destRoot "llvm-mingw"

          New-Item -ItemType Directory -Force -Path $destRoot | Out-Null
          New-Item -ItemType Directory -Force -Path $dest | Out-Null

          Write-Host "Downloading llvm-mingw from $url ..."
          Invoke-WebRequest -Uri $url -OutFile $zip -UseBasicParsing

          Write-Host "Extracting to $dest ..."
          Expand-Archive -Path $zip -DestinationPath $dest -Force

          # The archive usually unpacks into a subfolder; move contents up if needed
          $inner = Get-ChildItem -Path $dest | Where-Object { $_.PSIsContainer } | Select-Object -First 1
          if ($inner) {
            Write-Host "Flattening $($inner.FullName) into $dest ..."
            Get-ChildItem -Path $inner.FullName | Move-Item -Destination $dest -Force
            Remove-Item -Recurse -Force $inner.FullName
          }
          Remove-Item $zip -Force
          Write-Host "llvm-mingw installed under $dest"

      - name: Setting environment variables for the rest of the steps
        shell: powershell
        run: |
          $version = "${{ env.VERSION }}"
          if (-not $version) {
            $version = "unknown"
          }
          if ($version.StartsWith("v")) {
            $version = $version.Substring(1)
          }
          $cgo_enabled = "1"
          $cc  = "C:\tools\llvm-mingw\bin\x86_64-w64-mingw32-clang.exe"
          $cxx = "C:\tools\llvm-mingw\bin\x86_64-w64-mingw32-clang++.exe"
          Write-Host "Computed APP_VERSION=$version"
          "CGO_ENABLED=$cgo_enabled" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          "CC=$cc" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          "CXX=$cxx" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          "APP_VERSION=$version" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

      - name: Build Go binary (CGO, Windows) first time, compiler errors ignored
        shell: powershell
        env:
          APP_VERSION: ${{ env.APP_VERSION }}
        run: |
          New-Item -ItemType Directory -Force -Path (Join-Path $PWD "bin") | Out-Null

          $ldflags = "-X github.com/eduarddanziger/win-sound-dev-go-bridge/pkg/appinfo.Version=$Env:APP_VERSION"
          Write-Host "[non-fatal] Running initial go build with CGO..."
          go build -ldflags $ldflags -o (Join-Path $PWD.Path 'bin/')
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Initial go build failed with exit code $LASTEXITCODE; continuing pipeline as fetch-native and final build may still succeed."
            # Reset exit code to avoid failing the step
            $global:LASTEXITCODE = 0
          }

      - name: Run fetch-native script
        shell: powershell
        env:
          APP_VERSION: ${{ env.APP_VERSION }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          Write-Host "Running fetch-native.ps1 for $Env:GITHUB_REPOSITORY@$Env:GITHUB_REF_NAME (sha $Env:GITHUB_SHA, run $Env:GITHUB_RUN_ID) with APP_VERSION=$Env:APP_VERSION"
          .\scripts\fetch-native.ps1 -DllOutSubDir "bin"

      - name: Generate Windows version resource
        shell: powershell
        env:
          APP_VERSION: ${{ env.APP_VERSION }}
        run: |
          $version = $Env:APP_VERSION
          if (-not $version) {
            $version = "0.0.0"
          }

          if ($version.StartsWith("v")) {
            $version = $version.Substring(1)
          }

          $core = $version.Split('-')[0]
          $parts = $core.Split('.')
          while ($parts.Count -lt 4) {
            $parts += "0"
          }
          $major = [int]$parts[0]
          $minor = [int]$parts[1]
          $patch = [int]$parts[2]
          $build = [int]$parts[3]

          $fileVersionComma = "$major,$minor,$patch,$build"
          $productVersionComma = $fileVersionComma
          $fileVersionStr = $version
          $productVersionStr = $version

          $companyName = "Eduard Danziger"
          $fileDesc = "win-sound-dev-go-bridge"
          $internalName = "win-sound-dev-go-bridge"
          $originalFilename = "win-sound-dev-go-bridge.exe"
          $productName = "win-sound-dev-go-bridge"

          $root = "$PWD"
          $tmpl = Join-Path $root "internal\winres\version.rc.in"
          $outRc = Join-Path $root "internal\winres\version.rc"

          if (-not (Test-Path $tmpl)) {
            throw "Template version.rc.in not found at $tmpl"
          }

          $content = Get-Content $tmpl -Raw
          $content = $content.Replace("@FILEVERSION_COMMA@", $fileVersionComma)
          $content = $content.Replace("@PRODUCTVERSION_COMMA@", $productVersionComma)
          $content = $content.Replace("@FILEVERSION_STR@", $fileVersionStr)
          $content = $content.Replace("@PRODUCTVERSION_STR@", $productVersionStr)
          $content = $content.Replace("@COMPANY_NAME@", $companyName)
          $content = $content.Replace("@FILE_DESCRIPTION@", $fileDesc)
          $content = $content.Replace("@INTERNAL_NAME@", $internalName)
          $content = $content.Replace("@ORIGINAL_FILENAME@", $originalFilename)
          $content = $content.Replace("@PRODUCT_NAME@", $productName)

          New-Item -ItemType Directory -Force -Path (Split-Path $outRc) | Out-Null
          Set-Content -Path $outRc -Value $content -Encoding ascii

          Write-Host "Generated version.rc:"
          Get-Content $outRc

      - name: Compile Windows version resource
        shell: powershell
        run: |
          $root = "$PWD"
          $rc = Join-Path $root "internal\winres\version.rc"
          $outSyso = Join-Path $root "version.syso"

          if (-not (Test-Path $rc)) {
            throw "version.rc not found at $rc"
          }

          $windres = "C:\tools\llvm-mingw\bin\x86_64-w64-mingw32-windres.exe"
          if (-not (Test-Path $windres)) {
            throw "windres not found at $windres"
          }

          & $windres $rc -O coff -o $outSyso
          if ($LASTEXITCODE -ne 0) {
            throw "windres failed with exit code $LASTEXITCODE"
          }
          Write-Host "Generated $outSyso"

      - name: Rebuild Go binary after native fetch
        shell: powershell
        env:
          APP_VERSION: ${{ env.APP_VERSION }}
        run: |
          $ldflags = "-X github.com/eduarddanziger/win-sound-dev-go-bridge/pkg/appinfo.Version=$Env:APP_VERSION"
          Write-Host "Restarting go build with CGO..."
          go build -ldflags $ldflags -o (Join-Path $PWD.Path 'bin/')

      - name: Package bin directory
        shell: powershell
        env:
          APP_VERSION: ${{ env.APP_VERSION }}
        run: |
          $artifactName = "go-bridge-$Env:APP_VERSION.zip"
          Write-Host "Creating artifact $artifactName from bin/ ..."
          $binPath = Join-Path $PWD "bin"
          if (-not (Test-Path -Path $binPath)) {
            throw "bin directory not found; nothing to package."
          }
          $binGlob = Join-Path $binPath "*"
          Compress-Archive -Path $binGlob -DestinationPath (Join-Path $PWD $artifactName) -Force

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        env:
          APP_VERSION: ${{ env.APP_VERSION }}
        with:
          name: Artifacts
          path: go-bridge-${{ env.APP_VERSION }}.zip
          if-no-files-found: error

  publish:
    if: github.ref != 'refs/pull/develop'
    # if: startsWith(github.ref, 'refs/tags/v')
    needs:
      - setup-and-compute-version
      - build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: Artifacts
          path: build

      - name: Create or update Release
        env:
          VERS: ${{ needs.setup-and-compute-version.outputs.version }}
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
          if gh release view "$VERS" > /dev/null 2>&1; then
            echo "Release $VERS already exists; updating assets"
          else
            gh release create "$VERS" --title "Go-bridge $VERS" --notes "Release $VERS"
          fi
          # Upload or update the build artifact as a release asset
          if [ -f "build/go-bridge-$VERS.zip" ]; then
            gh release upload "$VERS" "build/go-bridge-$VERS.zip" --clobber
          elif [ -n "$(ls build 2>/dev/null)" ]; then
            # Fallback: upload any file(s) in the build directory
            gh release upload "$VERS" build/* --clobber
          else
            echo "No artifacts found in build/ to attach to release $VERS"
          fi
